#!/usr/bin/env ruby

require 'erb'

COMMANDS = [
    'init',
    'dev',
    'dev_down',
    'production',
    'production_down'
]

if ARGV.length != 1 || !COMMANDS.include?(ARGV.first.to_s.downcase)
  STDERR.puts "Invalid command"
  STDERR.puts "Usage: #{$0} { #{COMMANDS.join(' | ')} }"
  STDERR.puts
  exit 1
end

def file_path(path_from_rails_root)
  File.expand_path(File.dirname(__FILE__) + "/../#{path_from_rails_root}")
end

def env_file_exists?
  File.exists?(prod_env_file)
end

def prod_env_file
  file_path('docker-compose-production.env')
end

def prod_yml_file
  file_path('docker-compose-production.yml')
end

def docker_compose
  if system('which docker-compose >/dev/null 2>&1')
    'docker-compose'
  else
    'fig'
  end
end

def init
  unless system('docker inspect dungeon_db_data')
    puts 'Creating data container...'
    `docker create -v /var/lib/mysql -v /data --name dungeon_db_data mysql:latest`

    Dir.chdir(file_path('.')) do
      `#{docker_compose} build`

      bash_cmd = 'sleep 10 && rake db:create db:migrate db:seed'
      `#{docker_compose} run web bash -c "#{bash_cmd}"`
      `#{docker_compose} rm --force`
    end
  end
end

def dev
  system "#{docker_compose} up -d"
end

def dev_down
  system "#{docker_compose} stop"
end

def prep_prod
  yml_contents = ERB.new(File.read(file_path("docker/docker-compose-production.yml.erb"))).result(binding)
  File.write(prod_yml_file, yml_contents)
end

def production
  prep_prod
  system "#{docker_compose} --file \"#{prod_yml_file}\" up -d"
end

def production_down
  prep_prod
  system "#{docker_compose} --file \"#{prod_yml_file}\" stop"
end

send(ARGV.first.to_s.downcase.to_sym)